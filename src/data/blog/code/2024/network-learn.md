---
title: 计网碎碎念
pubDatetime: 2024-10-15T01:19:46.553Z
featured: false
tags:
  - net
  - notes
# ogImage: ../../assets/images/example.png # src/assets/images/example.png
description: 记录一点零散的计网笔记
---

## Table of contents

## udp与tcp

| 特性         | UDP                                        | TCP                                                      |
| ------------ | ------------------------------------------ | -------------------------------------------------------- |
| 连接方式     | 无连接                                     | 面向连接                                                 |
| 可靠性与控制 | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输（保证数据顺序和正确性），使用流量控制和拥塞控制 |
| 通信方式     | 支持一对一、一对多、多对一和多对多交互通信 | 只能是一对一通信                                         |
| 传输方式     | 面向报文                                   | 面向字节流                                               |
| 首部开销     | 小，仅8字节                                | 最小20字节，最大60字节                                   |
| 适用场景     | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用（如文件传输）                   |

> **拥塞控制**是指防止过多的数据注入网络，使网络中的路由器或链路不至于过载。
>
> 1.  **慢启动（Slow Start）**：刚开始时拥塞窗口（cwnd）较小，每收到一个ACK，cwnd加倍（指数增长）。直到到达慢启动门限（ssthresh）或出现丢包。
> 2.  **拥塞避免（Congestion Avoidance）**：当cwnd ≥ ssthresh后，进入线性增长（每经过一个往返时延RTT，cwnd+1）。防止窗口增长过快导致拥塞。
> 3.  **快重传（Fast Retransmit）**：连续收到3个相同的ACK（冗余ACK），立即重传丢失的数据包，无需等待超时。
> 4.  **快恢复（Fast Recovery）**：快重传后，不进入慢启动，而是将cwnd减半（cwnd=ssthresh），然后线性增长。只在TCP Reno等实现中有。
>
> 核心参数：**cwnd（拥塞窗口）**：控制发送方可发送的数据量。 **ssthresh（慢启动门限）**：阈值，决定慢启动和拥塞避免的切换。

> **流量控制**：
> 采用**滑动窗口（Sliding Window）**机制实现。
> 接收方会在每个ACK报文的窗口字段（window size）中，告知发送方“我还能再接收多少字节数据”。
> 发送方按接收方的窗口大小控制发送速率。

> 1. 面向报文:以“报文”为单位进行数据传输，每个报文相对独立，数据包之间有明确的边界。
> 2. 面向字节流:以“字节流”为单位进行数据传输，数据被看作连续的字节流，没有边界的概念。

## tcp三次握手与四次挥手

> - **Seq**：序列号，用于标识发送的数据字节流的顺序和唯一性，保证可靠传输。
> - **Ack**：确认号，表示期望收到的下一个字节的序号。

1、三次握手

1. **第一次握手**
   - 客户端发送SYN报文，随机产生一个初始序列号 **Seq=x**，进入SYN_SEND状态。
2. **第二次握手**
   - 服务器收到SYN后，回复SYN+ACK报文，**Seq=y, Ack=x+1**，进入SYN_RECV状态。
3. **第三次握手**
   - 客户端收到SYN+ACK后，回复ACK报文，**Seq=x+1, Ack=y+1**，连接建立，双方进入ESTABLISHED状态。

```
客户端                             服务器
  |   SYN, Seq=x   ------------->   |
  |                                 |
  |   <---- SYN+ACK, Seq=y, Ack=x+1 |
  |                                 |
  |   ACK, Seq=x+1, Ack=y+1 ------> |
```

我的理解是三次连接是确保双方首发能力都正常，然后安全进行连接。

想象这样一个场景，a约b说踢球吗，过了2小时，b回答说走，如果是2次连接，b就直接出发区球场，发现a不在，白去了。而3次连接就不存在这种情况，a回答说抱歉，有事情突然取消了。

简而言之就是三次握手能让客户端最后一次明确响应，排除历史报文干扰。如果只两次握手，服务器认为连接已建立，浪费资源，且可能出现“半连接”问题。

2、四次挥手

1. **第一次挥手**
   - 客户端发送FIN报文，**Seq=u**，进入FIN_WAIT_1状态。
2. **第二次挥手**
   - 服务器收到FIN后，回复ACK报文，**Seq=v, Ack=u+1**，进入CLOSE_WAIT状态。客户端进入FIN_WAIT_2状态。
3. **第三次挥手**
   - 服务器准备好关闭连接时，发送FIN报文，**Seq=w**，进入LAST_ACK状态。
4. **第四次挥手**
   - 客户端收到FIN后，回复ACK报文，**Seq=u+1, Ack=w+1**，进入TIME_WAIT状态，等待一段时间后彻底关闭。服务器收到ACK后关闭连接。

```
客户端                             服务器
  |   FIN, Seq=u    ------------->   |
  |                                  |
  |   <-------- ACK, Seq=v, Ack=u+1  |
  |                                  |
  |   <-----------  FIN, Seq=w       |
  |                                  |
  |   ACK, Seq=u+1, Ack=w+1 -------> |
```

---

tcp是全双工通信，双方的数据收发是独立的，每一方都需要单独关闭自己的“发送”通道和“接收”通道。

客户端主动关闭，发送FIN，告诉服务器“我发完了”。服务器收到FIN后，可能还有数据要发给客户端（比如最后的响应），所以立即ACK，但等自己数据发完了才发FIN。客户端收到服务器的FIN后，再ACK，双方都关闭。

## HTTP 版本

HTTP/0.9

- 发布年份：1991
- 特点：最早的HTTP版本，仅支持GET方法，无头部信息，通信简单。
- 应用场景：仅适用于超文本传输，极为简单的实现。

HTTP/1.0

- 发布年份：1996
- 特点：引入了请求和响应头部，支持多种方法（GET、POST、HEAD），每次请求/响应后断开连接。
- 优势：扩展了功能，支持更多媒体类型。
- 局限：每次通信都需新建连接，效率较低。

HTTP/1.1

- 发布年份：1997
- 特点：持久连接（Connection: keep-alive）、管道化请求、分块传输编码、缓存机制、部分内容请求（Range）。
- 优势：减少连接建立次数，提升效率，更多控制能力。
- 局限：队头阻塞（Head-of-line blocking）问题。

HTTP/2

- 发布年份：2015
- 特点：二进制分帧、多路复用、头部压缩（HPACK）、服务器推送（Server Push）。
- 优势：同一连接复用、减少延迟、提升性能。
- 局限：仍有TCP队头阻塞，部署复杂度提升。

HTTP/3

- 发布年份：2022
- 特点：基于QUIC协议（UDP之上）、内建加密、消除TCP队头阻塞、连接迁移更快。
- 优势：更低延迟、更快连接建立、提升移动端体验、连接更可靠。
- 局限：需要操作系统、网络设备和浏览器支持，部署和排障复杂。

---

## HTTPS

什么是 HTTPS？

- **全称**：HyperText Transfer Protocol Secure（超文本传输安全协议）
- **作用**：在 HTTP 协议基础上通过 SSL/TLS 加密数据，实现安全通信。
- **端口号**：默认 443

HTTPS 工作原理

1. **客户端发起请求**  
   客户端发送 `ClientHello`，包含**Client Random**（客户端随机数）。
2. **服务器响应**  
   服务器返回 `ServerHello`，包含**Server Random**（服务器随机数）；并发送证书（含公钥）。
3. **客户端验证证书**  
   客户端用内置 CA 公钥验证服务器证书。
4. **客户端生成 Pre-Master Secret**  
   客户端生成**Pre-Master Secret**（预主密钥），用服务器公钥加密后发送给服务器。
5. **服务器解密 Pre-Master Secret**  
   服务器用私钥解密得到 Pre-Master Secret。
6. **主密钥协商**  
   双方利用**Client Random**、**Server Random**、**Pre-Master Secret**，使用伪随机函数（PRF）生成**Master Secret**（主密钥），再派生出对称加密密钥。
7. **安全通信**  
   之后用协商好的对称密钥进行加密通信，内容安全可靠。

```
客户端                                       服务器
   |  ClientHello(Client Random)   ——>        |
   |  <——  ServerHello(Server Random)         |
   |  <——  Certificate(公钥)                  |
   |  <——  ServerHelloDone                    |
   |  验证证书                                 |
   |  生成Pre-Master Secret                   |
   |  用公钥加密Pre-Master Secret ——>          |
   |                                          |
   |            解密Pre-Master Secret（用私钥）|
   |                                          |
   |  Master Secret = PRF(Client Random, Server Random, Pre-Master Secret)
   |<——————— 对称加密通信 ———————>             |
```

> **说明**：
> 三个随机数（Client Random、Server Random、Pre-Master Secret）共同确定了后续加密的“主密钥”（Master Secret），保障数据安全性和唯一性。

---

HTTPS 的优势

- **防窃听**：传输内容被加密，第三方无法窃取敏感信息。
- **防篡改**：数据在传输过程中不可被中间人修改。
- **防钓鱼**：证书机制可验证服务器身份，防止伪造网站。

HTTPS 的局限

- 性能开销：加密解密带来一定 CPU 和资源消耗，不过现代硬件影响较小。
- 证书费用：正规 CA 证书可能需要付费
- 配置复杂：涉及证书申请、部署、续期等流程。

## 常见 HTTP 状态码

1xx 信息性

- **100 Continue**：继续，客户端应继续发送请求。
- **101 Switching Protocols**：切换协议，服务器同意更改请求的协议。

2xx 成功

- **200 OK**：请求成功，服务器已返回请求内容。
- **201 Created**：已创建，成功请求并创建了新资源。
- **204 No Content**：无内容，成功处理但无返回内容。

3xx 重定向

- **301 Moved Permanently**：永久重定向，请求的资源已被永久移动到新位置。
- **302 Found**：临时重定向，请求的资源临时移动。
- **304 Not Modified**：未修改，自从上次请求后，资源未被修改。

4xx 客户端错误

- **400 Bad Request**：错误请求，服务器无法理解请求。
- **401 Unauthorized**：未授权，需要身份验证。
- **403 Forbidden**：禁止访问，服务器拒绝请求。
- **404 Not Found**：未找到，请求的资源不存在。
- **405 Method Not Allowed**：方法不被允许，所请求的方法被禁止。
- **408 Request Timeout**：请求超时，服务器等候请求时超时。

5xx 服务器错误

- **500 Internal Server Error**：服务器内部错误，无法完成请求。
- **501 Not Implemented**：服务器不支持请求的功能。
- **502 Bad Gateway**：错误网关，服务器作为网关时收到无效响应。
- **503 Service Unavailable**：服务不可用，服务器当前无法处理请求。
- **504 Gateway Timeout**：网关超时，服务器作为网关时未及时收到响应。

---
