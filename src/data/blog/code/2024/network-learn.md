---
title: 计网碎碎念
pubDatetime: 2024-10-15T01:19:46.553Z
featured: false
tags:
  - net
  - notes
# ogImage: ../../assets/images/example.png # src/assets/images/example.png
description: 记录一点零散的计网笔记
---

## Table of contents

## udp与tcp

| 特性         | UDP                                        | TCP                                                      |
| ------------ | ------------------------------------------ | -------------------------------------------------------- |
| 连接方式     | 无连接                                     | 面向连接                                                 |
| 可靠性与控制 | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输（保证数据顺序和正确性），使用流量控制和拥塞控制 |
| 通信方式     | 支持一对一、一对多、多对一和多对多交互通信 | 只能是一对一通信                                         |
| 传输方式     | 面向报文                                   | 面向字节流                                               |
| 首部开销     | 小，仅8字节                                | 最小20字节，最大60字节                                   |
| 适用场景     | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用（如文件传输）                   |

> **拥塞控制**是指防止过多的数据注入网络，使网络中的路由器或链路不至于过载。
>
> 1.  **慢启动（Slow Start）**：刚开始时拥塞窗口（cwnd）较小，每收到一个ACK，cwnd加倍（指数增长）。直到到达慢启动门限（ssthresh）或出现丢包。
> 2.  **拥塞避免（Congestion Avoidance）**：当cwnd ≥ ssthresh后，进入线性增长（每经过一个往返时延RTT，cwnd+1）。防止窗口增长过快导致拥塞。
> 3.  **快重传（Fast Retransmit）**：连续收到3个相同的ACK（冗余ACK），立即重传丢失的数据包，无需等待超时。
> 4.  **快恢复（Fast Recovery）**：快重传后，不进入慢启动，而是将cwnd减半（cwnd=ssthresh），然后线性增长。只在TCP Reno等实现中有。
>
> 核心参数：**cwnd（拥塞窗口）**：控制发送方可发送的数据量。 **ssthresh（慢启动门限）**：阈值，决定慢启动和拥塞避免的切换。

> **流量控制**：
> 采用**滑动窗口（Sliding Window）**机制实现。
> 接收方会在每个ACK报文的窗口字段（window size）中，告知发送方“我还能再接收多少字节数据”。
> 发送方按接收方的窗口大小控制发送速率。

> 1. 面向报文:以“报文”为单位进行数据传输，每个报文相对独立，数据包之间有明确的边界。
> 2. 面向字节流:以“字节流”为单位进行数据传输，数据被看作连续的字节流，没有边界的概念。

## 粘包与拆包

1.  概念介绍

- **粘包**：在基于TCP协议的网络通信中，发送方连续发送多个数据包，接收方在接收时将多个包“粘”在一起，一次性收到多个包的数据，导致边界不清。
- **拆包**：一个数据包被拆分成多次接收，接收方一次只收到包的一部分数据，也会导致数据边界不清。

2.  产生原因

- TCP是面向字节流的协议，没有消息边界，底层只保证数据顺序和完整性，不保证一次发送就对应一次接收。
- 发送方连续发送数据，操作系统底层合并（Nagle算法、缓冲区等）。
- 接收方读取速度慢或缓冲区设置不当。
- 网络状况波动，导致数据分片或合并。

3.  影响

- 接收端无法准确区分每条消息的数据边界，数据解析出错。

4.  解决方法

常用协议设计方式有：

- **定长协议**：每条消息长度固定，接收端按固定长度读取。
- **分隔符协议**：每条消息结尾加特定分隔符（如换行符），接收端按分隔符切分。
- **长度字段协议**：在消息头部增加长度字段，指明消息体长度，接收端先读长度，再按长度读消息体。

```
|---msg1---||---msg2---||---msg3---|  // 发送方
|---msg1---|---msg2---|---msg3---|   // 接收方一次性收到（粘包）
|---msg1---|
|---msg2---|---msg3---|           // 或者分多次收到（拆包）
```

## tcp三次握手与四次挥手

> - **Seq**：序列号，用于标识发送的数据字节流的顺序和唯一性，保证可靠传输。
> - **Ack**：确认号，表示期望收到的下一个字节的序号。

1、三次握手

1. **第一次握手**
   - 客户端发送SYN报文，随机产生一个初始序列号 **Seq=x**，进入SYN_SEND状态。
2. **第二次握手**
   - 服务器收到SYN后，回复SYN+ACK报文，**Seq=y, Ack=x+1**，进入SYN_RECV状态。
3. **第三次握手**
   - 客户端收到SYN+ACK后，回复ACK报文，**Seq=x+1, Ack=y+1**，连接建立，双方进入ESTABLISHED状态。

```
客户端                             服务器
  |   SYN, Seq=x   ------------->   |
  |                                 |
  |   <---- SYN+ACK, Seq=y, Ack=x+1 |
  |                                 |
  |   ACK, Seq=x+1, Ack=y+1 ------> |
```

我的理解是三次连接是确保双方首发能力都正常，然后安全进行连接。

想象这样一个场景，a约b说踢球吗，过了2小时，b回答说走，如果是2次连接，b就直接出发区球场，发现a不在，白去了。而3次连接就不存在这种情况，a回答说抱歉，有事情突然取消了。

简而言之就是三次握手能让客户端最后一次明确响应，排除历史报文干扰。如果只两次握手，服务器认为连接已建立，浪费资源，且可能出现“半连接”问题。

2、四次挥手

1. **第一次挥手**
   - 客户端发送FIN报文，**Seq=u**，进入FIN_WAIT_1状态。
2. **第二次挥手**
   - 服务器收到FIN后，回复ACK报文，**Seq=v, Ack=u+1**，进入CLOSE_WAIT状态。客户端进入FIN_WAIT_2状态。
3. **第三次挥手**
   - 服务器准备好关闭连接时，发送FIN报文，**Seq=w**，进入LAST_ACK状态。
4. **第四次挥手**
   - 客户端收到FIN后，回复ACK报文，**Seq=u+1, Ack=w+1**，进入TIME_WAIT状态，等待一段时间后彻底关闭。服务器收到ACK后关闭连接。

```
客户端                             服务器
  |   FIN, Seq=u    ------------->   |
  |                                  |
  |   <-------- ACK, Seq=v, Ack=u+1  |
  |                                  |
  |   <-----------  FIN, Seq=w       |
  |                                  |
  |   ACK, Seq=u+1, Ack=w+1 -------> |
```

---

tcp是全双工通信，双方的数据收发是独立的，每一方都需要单独关闭自己的“发送”通道和“接收”通道。

客户端主动关闭，发送FIN，告诉服务器“我发完了”。服务器收到FIN后，可能还有数据要发给客户端（比如最后的响应），所以立即ACK，但等自己数据发完了才发FIN。客户端收到服务器的FIN后，再ACK，双方都关闭。

## HTTP 版本

HTTP/0.9

- 发布年份：1991
- 特点：最早的HTTP版本，仅支持GET方法，无头部信息，通信简单。
- 应用场景：仅适用于超文本传输，极为简单的实现。

HTTP/1.0

- 发布年份：1996
- 特点：引入了请求和响应头部，支持多种方法（GET、POST、HEAD），每次请求/响应后断开连接。
- 优势：扩展了功能，支持更多媒体类型。
- 局限：每次通信都需新建连接，效率较低。

HTTP/1.1

- 发布年份：1997
- 特点：持久连接（Connection: keep-alive）、管道化请求、分块传输编码、缓存机制、部分内容请求（Range）。
- 优势：减少连接建立次数，提升效率，更多控制能力。
- 局限：队头阻塞（Head-of-line blocking）问题。

HTTP/2

- 发布年份：2015
- 特点：二进制分帧、多路复用、头部压缩（HPACK）、服务器推送（Server Push）。
- 优势：同一连接复用、减少延迟、提升性能。
- 局限：仍有TCP队头阻塞，部署复杂度提升。

HTTP/3

- 发布年份：2022
- 特点：基于QUIC协议（UDP之上）、内建加密、消除TCP队头阻塞、连接迁移更快。
- 优势：更低延迟、更快连接建立、提升移动端体验、连接更可靠。
- 局限：需要操作系统、网络设备和浏览器支持，部署和排障复杂。

---

## HTTPS

什么是 HTTPS？

- **全称**：HyperText Transfer Protocol Secure（超文本传输安全协议）
- **作用**：在 HTTP 协议基础上通过 SSL/TLS 加密数据，实现安全通信。
- **端口号**：默认 443

HTTPS 工作原理

1. **客户端发起请求**  
   客户端发送 `ClientHello`，包含**Client Random**（客户端随机数）。
2. **服务器响应**  
   服务器返回 `ServerHello`，包含**Server Random**（服务器随机数）；并发送证书（含公钥）。
3. **客户端验证证书**  
   客户端用内置 CA 公钥验证服务器证书。
4. **客户端生成 Pre-Master Secret**  
   客户端生成**Pre-Master Secret**（预主密钥），用服务器公钥加密后发送给服务器。
5. **服务器解密 Pre-Master Secret**  
   服务器用私钥解密得到 Pre-Master Secret。
6. **主密钥协商**  
   双方利用**Client Random**、**Server Random**、**Pre-Master Secret**，使用伪随机函数（PRF）生成**Master Secret**（主密钥），再派生出对称加密密钥。
7. **安全通信**  
   之后用协商好的对称密钥进行加密通信，内容安全可靠。

```
客户端                                       服务器
   |  ClientHello(Client Random)   ——>        |
   |  <——  ServerHello(Server Random)         |
   |  <——  Certificate(公钥)                  |
   |  <——  ServerHelloDone                    |
   |  验证证书                                 |
   |  生成Pre-Master Secret                   |
   |  用公钥加密Pre-Master Secret ——>          |
   |                                          |
   |            解密Pre-Master Secret（用私钥）|
   |                                          |
   |  Master Secret = PRF(Client Random, Server Random, Pre-Master Secret)
   |<——————— 对称加密通信 ———————>             |
```

> **说明**：
> 三个随机数（Client Random、Server Random、Pre-Master Secret）共同确定了后续加密的“主密钥”（Master Secret），保障数据安全性和唯一性。

---

HTTPS 的优势

- **防窃听**：传输内容被加密，第三方无法窃取敏感信息。
- **防篡改**：数据在传输过程中不可被中间人修改。
- **防钓鱼**：证书机制可验证服务器身份，防止伪造网站。

HTTPS 的局限

- 性能开销：加密解密带来一定 CPU 和资源消耗，不过现代硬件影响较小。
- 证书费用：正规 CA 证书可能需要付费
- 配置复杂：涉及证书申请、部署、续期等流程。

## 常见 HTTP 状态码

1xx 信息性

- **100 Continue**：继续，客户端应继续发送请求。
- **101 Switching Protocols**：切换协议，服务器同意更改请求的协议。

2xx 成功

- **200 OK**：请求成功，服务器已返回请求内容。
- **201 Created**：已创建，成功请求并创建了新资源。
- **204 No Content**：无内容，成功处理但无返回内容。

3xx 重定向

- **301 Moved Permanently**：永久重定向，请求的资源已被永久移动到新位置。
- **302 Found**：临时重定向，请求的资源临时移动。
- **304 Not Modified**：未修改，自从上次请求后，资源未被修改。

4xx 客户端错误

- **400 Bad Request**：错误请求，服务器无法理解请求。
- **401 Unauthorized**：未授权，需要身份验证。
- **403 Forbidden**：禁止访问，服务器拒绝请求。
- **404 Not Found**：未找到，请求的资源不存在。
- **405 Method Not Allowed**：方法不被允许，所请求的方法被禁止。
- **408 Request Timeout**：请求超时，服务器等候请求时超时。

5xx 服务器错误

- **500 Internal Server Error**：服务器内部错误，无法完成请求。
- **501 Not Implemented**：服务器不支持请求的功能。
- **502 Bad Gateway**：错误网关，服务器作为网关时收到无效响应。
- **503 Service Unavailable**：服务不可用，服务器当前无法处理请求。
- **504 Gateway Timeout**：网关超时，服务器作为网关时未及时收到响应。

---

## GET 与 POST 请求的区别

1.  基本定义

- **GET**：用于请求访问指定的资源，返回数据。参数通过URL传递。
- **POST**：用于向指定资源提交数据进行处理，参数在请求体中传递。

2.  参数传递方式

- **GET**：参数附加在URL之后，格式如 `?key1=value1&key2=value2`
- **POST**：参数在HTTP请求体中，用户不可见。

3.  安全性

- **GET**：安全性较低，参数暴露在URL，容易被篡改、缓存和记录。
- **POST**：相对安全，参数不会出现在URL中，但仍需配合HTTPS保证安全。

4.  数据长度限制

- **GET**：受URL长度限制（通常为2KB~8KB）。
- **POST**：理论上无长度限制，受服务器配置影响。

5.  幂等性

- **GET**：幂等（多次请求结果相同，不影响资源状态）。
- **POST**：非幂等（多次请求可能产生不同结果，如多次提交表单）。

6. 缓存与书签

- **GET**：可被缓存，可被加入书签。
- **POST**：不会被缓存，也不能加入书签。

7.  适用场景

- **GET**：获取数据、查询操作。
- **POST**：提交数据、表单提交、上传文件。

---

| 对比项    | GET        | POST       |
| --------- | ---------- | ---------- |
| 传参位置  | URL        | 请求体     |
| 数据长度  | 有限制     | 理论无限   |
| 安全性    | 低         | 较高       |
| 幂等性    | 幂等       | 非幂等     |
| 缓存/书签 | 支持       | 不支持     |
| 适用场景  | 查询、获取 | 提交、修改 |

## 短轮询 长轮询

1. 短轮询

- **原理**：客户端定时（如每3秒）向服务器发送请求，询问是否有新数据。
- **响应**：服务器每次收到请求都会立即返回（无论有无新数据）。
- **优点**：
  - 实现简单，兼容性好。
- **缺点**：
  - 实时性差，有延迟。
  - 浪费带宽和服务器资源（大量无效请求）。
- **适用场景**：
  - 实时性要求不高，如新闻评论刷新、定时同步。

```javascript
function shortPolling() {
  setInterval(async () => {
    const response = await fetch("/api/data");
    const data = await response.json();
    console.log("短轮询收到数据：", data);
  }, 3000); // 每3秒请求一次
}
shortPolling();
```

---

2.  长轮询

- **原理**：客户端发送请求，服务器如果没有新数据会挂起请求（如挂10秒），有新数据立即返回；若超时无新数据，则返回空响应，客户端立即再次发起请求。
- **响应**：服务器只有有新数据时才立刻响应，否则保持连接直到有数据或超时。
- **优点**：
  - 实时性较好，减少无效请求。
  - 节省带宽和服务器资源。
- **缺点**：
  - 实现稍复杂（需处理连接超时、重连等）。
- **适用场景**：
  - 需要一定实时性的应用，如聊天、消息推送。

```javascript
async function longPolling() {
  while (true) {
    try {
      const response = await fetch("/api/long-poll");
      const data = await response.json();
      console.log("长轮询收到数据：", data);
    } catch (error) {
      console.error("长轮询出错，重试中...", error);
    }
    // 收到响应后立即发起下一次请求
  }
}
longPolling();
```

## SSE

1.  基本概念

- **SSE（Server-Sent Events）** 是一种单向实时通信机制，允许服务器通过HTTP协议主动推送事件/数据到浏览器客户端。
- SSE 基于 HTTP 协议（通常是 HTTP/1.1），属于 HTML5 标准的一部分。
- 与 WebSocket 不同，SSE 是单向的（服务器 → 客户端），客户端不能主动发消息到服务器。

---

2. 工作原理

- 客户端通过 `EventSource` 对象向服务器发起一次 HTTP 请求，服务器保持该连接不断开。
- 服务器通过特殊的 MIME 类型 `text/event-stream` 持续推送数据。
- 客户端通过监听事件来接收数据。

---

3. 特点优缺点

**优点：**

- 实现简单，浏览器原生支持（EventSource）。
- 基于 HTTP，容易穿透防火墙和代理。
- 支持自动重连与事件ID。
- 天然支持文本流（如JSON、文本）。

**缺点：**

- 仅支持服务器到客户端单向通信。
- 不适用二进制数据（仅文本）。
- 受限于 HTTP/1.x，连接数量受限。
- IE 不支持（Edge 支持）。

---

```javascript
const source = new EventSource("/sse");
source.onmessage = function (event) {
  console.log("收到SSE消息:", event.data);
};
source.onerror = function (e) {
  console.error("SSE连接出错", e);
};
```

---

4. 与 WebSocket、长轮询对比

| 特性     | SSE                   | WebSocket        | 长轮询        |
| -------- | --------------------- | ---------------- | ------------- |
| 通信方向 | 单向（服务端→客户端） | 双向             | 单向/模拟双向 |
| 实时性   | 高                    | 高               | 较高          |
| 适用场景 | 实时推送、通知        | 聊天、游戏、协作 | 通用消息      |

---

## WebSocket

1.  基本概念

- **WebSocket** 是一种基于 TCP 的全双工、持久化通信协议，允许客户端和服务器之间实现实时、双向通信。
- WebSocket 由 HTML5 标准引入，弥补了 HTTP 协议单向通信和高延迟的不足。
- 典型应用场景：在线聊天、在线游戏、协同编辑、实时行情推送等。

---

2.  工作原理

- **握手阶段**：客户端通过 HTTP/HTTPS 协议向服务器发起 WebSocket 握手请求（使用 `Upgrade: websocket` 头），服务器响应同意升级后，建立持久连接。
- **数据传输阶段**：双方可在同一连接上随时互发消息，且数据格式比 HTTP 更轻量。
- **关闭阶段**：任意一方可主动关闭连接。

---

3. 特点优缺点

**优点：**

- 真正的双向通信（全双工）。
- 实时性高，延迟低。
- 只建立一次连接，节省资源和带宽。
- 传输效率高，数据包开销小。

**缺点：**

- 需要服务器和客户端都支持 WebSocket 协议。
- 部分老旧代理、防火墙可能不兼容。
- 服务器需管理大量长连接，内存消耗较大。

---

```javascript
const ws = new WebSocket("ws://localhost:3000");
ws.onopen = () => {
  console.log("WebSocket连接已打开");
  ws.send("你好，服务器！");
};
ws.onmessage = event => {
  console.log("收到消息：", event.data);
};
ws.onclose = () => {
  console.log("WebSocket连接已关闭");
};
ws.onerror = err => {
  console.error("WebSocket出错:", err);
};
```
